<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python学习</title>
    <url>/2024/03/24/Python%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-1-数组初始化"><a href="#1-1-数组初始化" class="headerlink" title="1.1 数组初始化"></a>1.1 数组初始化</h2><p><code>dp = [[0 for _ in range(n)] for _ in range(m)]</code><br><code>dp = [[0]*n]*m</code> 会导致浅拷贝，修改其中一个元素会导致整列元素都被修改</p>
]]></content>
      <categories>
        <category>计算机语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习</title>
    <url>/2024/03/26/Cpp/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><hr>
<p>变量类型</p>
<ol>
<li>字符: char</li>
<li>浮点: float, double</li>
<li>枚举: enum用于定义一组命名的整数常量</li>
<li>数组: type[]或type[size]：用于表示具有相同类型的元素组成的数组</li>
<li>结构体: struct：用于定义包含多个不同类型成员的结构</li>
<li>共用体: union：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型<br>!!!字符串: 有两种方式来表示字符串</li>
</ol>
<ul>
<li>C风格字符串: <code>char str[] = "Hello"; char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};</code></li>
<li>String类:<br>  C++标准库提供了string类类型，用于操作字符串: <code>#include &lt;string&gt;</code><br>  <code>string str = "Hello";</code></li>
</ul>
<hr>
<p>变量修饰符</p>
<ol>
<li>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。<br>static如果用于class的成员变量，表示该成员变量是所有对象共享的，不会因为对象的不同而改变。</li>
<li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置.</li>
</ol>
<hr>
<p>数学运算符</p>
<ol>
<li>取模运算符: %，返回除法的余数</li>
<li>除法运算符: /，返回除法的商 (整数除法只保留整数部分，不会四舍五入) </li>
<li>自增自减: ++, —</li>
<li>除法要得到小数: 除数或被除数有一个是浮点数</li>
<li>逻辑运算符: &amp;&amp;, ||, !</li>
<li>强制转换: int(2.2200)</li>
<li>指针运算符: &amp;, *<blockquote>
<p>取模%, 逻辑运算符, 自增减不同于python, 要注意</p>
</blockquote>
</li>
</ol>
<hr>
<p>循环/条件</p>
<ol>
<li>if…else if….else</li>
<li><code>#include&lt;string&gt;</code></li>
<li><code>cout&lt;&lt;"str.size()"</code></li>
</ol>
<hr>
<p>函数</p>
<ol>
<li>函数声明<br>参数的名称并不重要，只有参数的类型是必需的: int max(int, int);</li>
<li>函数调用<br>传值: 略<br>传递指针:<br> <code>void swap(int *x, int *y); //声明</code><br> <code>void swap(int *x, int *y) { //定义}</code><br> <code>swap(&amp;a, &amp;b); //调用</code><br>传递引用:<br> <code>void swap(int &amp;x, int &amp;y); //声明</code><br> <code>void swap(int &amp;x, int &amp;y) { //定义}</code><br> <code>swap(a, b); //调用</code></li>
</ol>
<hr>
<p>数组</p>
<ol>
<li>声明,初始化<br><code>type arrayName [ arraySize ];</code><br>必须指定数组的大小，数组的大小必须是一个大于零的整数常量，type可以是任意有效的数据类型<br><code>double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};</code><br><code>double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};</code><br><code>balance[4] = 50.0; //创建含有4个元素的数组</code></li>
<li>多维数组</li>
</ol>
<hr>
<p>指针数组和数组指针</p>
<p><font color="red">[]的优先级高于*</font></p>
<ol>
<li>概念<br>指针数组: int <em>p[5]; //p是一个数组，数组中的元素是指针<br>数组指针: int (</em>p)[5]; //p是一个指针，指向一个具有5个元素的数组</li>
<li>二维数组指针的解引用<br>以二维数组a[2][3]={1, 2, 3, 4 ,5, 6};为例（第一维是行，第二维是列）<br>第一种：*(*a+1)————等价于a[0][1]，因为<em>的优先级比+高，所以先解引用，进入第二维在第二维里面地址+1，再次解引用得到元素值<br>第二种：\</em>(*(a+1))———等价于a[1][0]，比上面第一种多加了一个括号，括号优先级最高，先+1移动地址（注意是在第一维里面移动），然后解引用进入第二维，再解引用得到元素的值<br>第三种：*(&amp;a[0][0]+1)—等价于a[0][1]，这里使用了&amp;取地址符，将原本表示第一个元素的a[0][0]返回到第二个维度，然后第二维地址+1，再解引用得到元素的值</li>
<li>举例<br><em>(a[1]+1)————表示的是a[1][1]的值<br>(</em>a+1)[1]————表示的是a[0][2]的值<br>第二个解析: 因为[]的优先级是比*高的所以这里的括号不能去掉，第一步先解引用进入第二维度(*优先级高于+），然后第二维地址+1，然后再在当前基础上再移动一次地址，最后解引用</li>
<li>指向字符串数组的指针数组:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *names[] = {</span><br><span class="line">   <span class="string">"Zara Ali"</span>,</span><br><span class="line">   <span class="string">"Hina Ali"</span>,</span><br><span class="line">   <span class="string">"Nuha Ali"</span>,</span><br><span class="line">   <span class="string">"Sara Ali"</span>,</span><br><span class="line">};</span><br><span class="line">cout &lt;&lt; names[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol>
<li>引用<br>直接输出引用变量, 会输出引用变量的值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span></span><br><span class="line"><span class="type">int</span>&amp;    r = i;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; r &lt;&lt; endl; <span class="comment">//输出两个5</span></span><br></pre></td></tr></table></figure>
引用通常用于函数参数列表和函数返回值。</li>
</ol>
<hr>
<ol>
<li>结构体<br>成员访问运算符（.）<br>结构体的变量的赋值举例(字符串):<code>strcpy(book1.title, "C++ 教程");</code></li>
<li>结构体指针<br>成员访问运算符（-&gt;）<br><code>struct_pointer-&gt;title;</code></li>
<li>typedef关键字<br>创建别名: 可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字<br><code>typedef struct Books { ... } Book;</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">}Books;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>类class</p>
<ol>
<li>私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问</li>
<li>成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。—— e.g. <code>double Box::getVolume(void)</code></li>
<li>构造函数<br>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。<br>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>使用初始化列表来初始化字段:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c)</span><br><span class="line">{</span><br><span class="line">  ....</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
<li>析构函数<br>类的析构函数是类的一种特殊的成员函数，它会在每次<strong>删除所创建的对象</strong>时执行。(delete)<br>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</li>
</ol>
<hr>
<p>继承</p>
<ol>
<li>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">{</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>{ </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/03/26/x5GSmZoRq1wtHJf.png" width="100%"></li>
</ol>
<ol>
<li>一个派生类继承了所有的基类方法，但下列情况除外：<br>基类的构造函数、析构函数和拷贝构造函数。<br>基类的重载运算符。TODO: 查阅<br>基类的友元函数。TODO: 查阅</li>
<li><p>继承类型<br><img src="https://s2.loli.net/2024/03/26/7jq92XUCgW5VQZS.png" width="100%"></p>
</li>
<li><p>多继承</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">{</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>重载<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b)</span><br><span class="line">{</span><br><span class="line">   Box box;</span><br><span class="line">   box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">   box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">   box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">   <span class="keyword">return</span> box;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>TODO: 重载详细</p>
<hr>
<p>多态</p>
<ol>
<li>虚函数<br>需要在父类的调用函数之前加上virtual, 声明为虚函数. 如果不设置,静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为调用函数在程序<strong>编译期间就已经设置好了</strong>. </li>
<li>纯虚函数<br>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。<br><code>virtual int area() = 0;</code></li>
</ol>
<hr>
<p>数据抽象<br>在 C++ 中，使用类来定义我们自己的抽象数据类型（ADT）<br>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。<strong>数据封装</strong>引申出了另一个重要的 OOP 概念，即数据隐藏。</p>
<p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>
<blockquote>
<p>C++中, 虚函数可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。<br>一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。<br>编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！<br>纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。</p>
</blockquote>
<hr>
<p>动态内存</p>
<ol>
<li>程序内存<br>栈：在函数内部声明的所有变量都将占用栈内存。<br>堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
<li>动态分配值<br>new+delete<br>malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">tmp = <span class="keyword">new</span> <span class="type">double</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>数组</p>
<figure class="highlight cpp"><figcaption><span>基本用法</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">delete</span> [] p; <span class="comment">//释放数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>一维数组</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>二维数组: 3行4列</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **p = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">{</span><br><span class="line">   p[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">{</span><br><span class="line">   <span class="keyword">delete</span> [] p[i];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
<li><p>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Box</span>() { </span><br><span class="line">         cout &lt;&lt; <span class="string">"调用构造函数！"</span> &lt;&lt;endl; </span><br><span class="line">      }</span><br><span class="line">      ~<span class="built_in">Box</span>() { </span><br><span class="line">         cout &lt;&lt; <span class="string">"调用析构函数！"</span> &lt;&lt;endl; </span><br><span class="line">      }</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   Box* myBoxArray = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">delete</span> [] myBoxArray; <span class="comment">// 删除数组</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>[ ] C++11新特性</li>
<li>[ ] 调用函数传递数组参数时, 是否需要写方括号以及数组大小</li>
</ul>
]]></content>
      <categories>
        <category>计算机语言</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>hexo基本语法</title>
    <url>/2024/03/23/hexo%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p><em>Not completed …</em></p>
<h1 id="1-hexo命令"><a href="#1-hexo命令" class="headerlink" title="1. hexo命令"></a>1. hexo命令</h1><h2 id="1-1-创建新layout"><a href="#1-1-创建新layout" class="headerlink" title="1.1 创建新layout"></a>1.1 创建新layout</h2><p><code>hexo new [不填|post|page|draft] &quot;文章标题&quot;</code></p>
<ol>
<li><p>post<br>下面的234都可以通过meta信息指定<br>指定位置：hexo new post “文章标题” /subdir/subdir/<br>指定分类：hexo new post “文章标题” —category “分类名称”<br>指定标签：hexo new post “文章标题” —tags “标签1 标签2”<br>指定布局：hexo new post “文章标题” —layout “布局名称”</p>
</li>
<li><p>draft<br>新建: <code>hexo new draft &#39;博文示例&#39;</code><br>在本地服务器预览: <code>hexo s --draft</code><br>发布草稿: <code>hexo publish post 博文示例</code></p>
<blockquote>
<p>ps: 这里post之后的文件名称不需要写全, 只需要写前几个字符即可. 如果没有找到对应的文件会报错的</p>
</blockquote>
</li>
<li><p>page<br>TODO: to fill …</p>
</li>
</ol>
<h2 id="1-2-生成静态文件并部署"><a href="#1-2-生成静态文件并部署" class="headerlink" title="1.2 生成静态文件并部署"></a>1.2 生成静态文件并部署</h2><p><code>hexo d -g</code></p>
<blockquote>
<p>缩写：命令可以缩写，条件是没有开头几个字母相同的其它命令。<code>hexo s</code> 实际上是 <code>hexo server</code> 的缩写；下文中 <code>hexo d</code> 是 <code>hexo deploy</code> 的缩写，<code>hexo g</code> 是 <code>hexo generate</code> 的缩写；<code>hexo clean</code> 不能缩写为 <code>hexo c</code>，因为存在命令 <code>hexo config</code> ，但是可以缩写为 <code>hexo cl</code> 。</p>
</blockquote>
<h1 id="2-特殊语法"><a href="#2-特殊语法" class="headerlink" title="2. 特殊语法"></a>2. 特殊语法</h1><h2 id="2-1-note"><a href="#2-1-note" class="headerlink" title="2.1 note"></a>2.1 note</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">class_name: default, primary, success, info, warning, danger</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note default"><p>class_name: default, primary, success, info, warning, danger</p>
</div>
<h2 id="2-2-tabs"><a href="#2-2-tabs" class="headerlink" title="2.2 tabs"></a>2.2 tabs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs %&#125;</span><br><span class="line">&lt;!-- tab Tab1 --&gt;</span><br><span class="line">Content of Tab1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab Tab2 --&gt;</span><br><span class="line">Content of Tab2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="tab1"><ul class="nav-tabs"><li class="tab active"><a href="#tab1-1">Tab1</a></li><li class="tab"><a href="#tab1-2">Tab2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab1-1"><p>Content of Tab1</p></div><div class="tab-pane" id="tab1-2"><p>Content of Tab2</p></div></div></div>
<h2 id="2-3-post-link"><a href="#2-3-post-link" class="headerlink" title="2.3 post_link"></a>2.3 post_link</h2><p>用于blog内部跳转<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 文件名 %&#125;</span><br></pre></td></tr></table></figure><br><a href="/2024/03/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="动态规划理论基础">动态规划理论基础</a></p>
<h1 id="3-公式"><a href="#3-公式" class="headerlink" title="3. 公式"></a>3. 公式</h1><p>这里推荐一个图片转latex公式的网站Simpletex: <a href="https://simpletex.cn/">https://simpletex.cn/</a><br>算是<a href="https://mathpix.com/">mathpix</a>的平替吧, 日常偶尔用用Simpletex应该也够了</p>
<h2 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h2><p>安装插件katex插件: <code>npm install hexo-renderer-katex --save</code><br>修改配置文件(如果没有对应的配置项, 则添加):<br><figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Katex数学公式(allpost设置为false时只有头部设置math:true的文章才开启)</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">allpost:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">copy_tex:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span> <span class="string">themes/next/_config.yml</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>插件安装完成, 只需在post的头部添加<code>mathjax: true</code>即可开启公式支持</p>
<h2 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h2><p>TODO: to fill …</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>有些复杂公式hexo渲染会有问题</p>
<ol>
<li>换行<br>例如这里, 用simpletex得到的公式, 只有\\, 虽然本地md渲染正确, 但是hexo就会出错, 应该改成 \\\\, 这里mathjax应该把\解析为了转义字符<br><img src=https://s2.loli.net/2024/03/26/GDkhwViYyO5ldEu.png width='100%'></li>
<li>大括号<br>尽量不要写’\{‘, 写\lbrace比较好, 右括号也一样</li>
</ol>
<p align='right'>Continuously updated, so stay tuned!</p>]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo环境配置</title>
    <url>/2024/03/23/hexo%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p><em>Not completed …</em></p>
<h1 id="1-hexo搭建"><a href="#1-hexo搭建" class="headerlink" title="1. hexo搭建"></a>1. hexo搭建</h1><p>hexo是一个快速、简洁且高效的博客框架，基于Node.js。hexo的主要功能包括：快速生成静态文件、部署到GitHub Pages、支持Markdown、支持插件等。本文主要介绍hexo的hexo环境配置 &amp; GitHub Pages部署</p>
<h2 id="1-1-下载运行程序"><a href="#1-1-下载运行程序" class="headerlink" title="1.1 下载运行程序"></a>1.1 下载运行程序</h2><p><a href="https://git-scm.com/">Git下载</a><br><a href="https://nodejs.org/en/">Nodejs下载</a></p>
<h2 id="1-2-安装hexo"><a href="#1-2-安装hexo" class="headerlink" title="1.2 安装hexo"></a>1.2 安装hexo</h2><p><code>npm install -g hexo-cli</code></p>
<p>测试是否安装成功</p>
<p><code>hexo -v</code></p>
<p>如果显示多行版本信息，则安装成功</p>
<h2 id="1-3-初始化hexo"><a href="#1-3-初始化hexo" class="headerlink" title="1.3 初始化hexo"></a>1.3 初始化hexo</h2><p>打开想要存放博客的文件夹，右键选择Git Bash Here，输入以下命令</p>
<p><code>hexo init</code></p>
<h2 id="1-4-安装主题"><a href="#1-4-安装主题" class="headerlink" title="1.4 安装主题"></a>1.4 安装主题</h2><p><code>git clone https://github.com/theme-next/hexo-theme-next next</code></p>
<p>根据需要修改全局配置文件_config.yml,以及主题配置文件themes/next/_config.yml</p>
<h2 id="1-5-本地预览"><a href="#1-5-本地预览" class="headerlink" title="1.5 本地预览"></a>1.5 本地预览</h2><p><code>hexo server</code></p>
<blockquote>
<p>ps: 如果端口占用，可以使用hexo server -p <strong><strong>指定端口，</strong></strong>为端口号，例如hexo server -p 40000</p>
</blockquote>
<p>以上能够完成本地预览，但是还没有同步到github上，接下来就是部署到GitHub Pages</p>
<h1 id="2-GitHub-Pages部署方法1-Deploy-From-a-Branch"><a href="#2-GitHub-Pages部署方法1-Deploy-From-a-Branch" class="headerlink" title="2. GitHub Pages部署方法1 - Deploy From a Branch"></a>2. GitHub Pages部署方法1 - Deploy From a Branch</h1><h2 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1 创建仓库"></a>2.1 创建仓库</h2><p>新建一个仓库，仓库名为用户名.github.io，仓库名和用户名一致!</p>
<h2 id="2-2-部署"><a href="#2-2-部署" class="headerlink" title="2.2 部署"></a>2.2 部署</h2><ol>
<li><p>本地和远程仓库关联</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;url&gt;  # url为仓库地址,例如 git@github.com:&lt;name&gt;/&lt;name&gt;.github.io.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装插件<br><code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>配置<br>修改_config.yml文件</p>
<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> <span class="comment"># 直接复制ssh或者https地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></li>
<li>上传<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-3-pages设置"><a href="#2-3-pages设置" class="headerlink" title="2.3 pages设置"></a>2.3 pages设置</h2><p>进入仓库的settings，找到GitHub Pages，选择source为main分支，保存即可</p>
<h1 id="3-Github-Pages部署方法2-WorkFlow"><a href="#3-Github-Pages部署方法2-WorkFlow" class="headerlink" title="3. Github Pages部署方法2 - WorkFlow"></a>3. Github Pages部署方法2 - WorkFlow</h1><p>一种看起来非常高大上牛逼的方法，但也是真的很麻烦，翻阅博客无数，最后error和warning也无数，放弃。看在自己差点通了个宵的份上，还是记录一下。</p>
<h2 id="3-1-创建密钥"><a href="#3-1-创建密钥" class="headerlink" title="3.1 创建密钥"></a>3.1 创建密钥</h2><p>首先根据这篇文章生成ssh密钥对.<br>在仓库的settings，找到secrets下的Actions，点击New repository secret，创建一个名为DEPLOY_KEY的密钥，值为ssh私钥.<br>在仓库的settings，找到Deploy keys，点击Add deploy key，将公钥粘贴进去，勾选Allow write access.</p>
<p><img src="https://s2.loli.net/2024/03/24/qoROkXreS2d6nx5.png" alt=""></p>
<h2 id="3-2-创建workflow"><a href="#3-2-创建workflow" class="headerlink" title="3.2 创建workflow"></a>3.2 创建workflow</h2><p>在仓库的.github/workflows目录下创建一个deploy.yml文件，内容如下。<br>这里要修改两个地方,其余不用改动：</p>
<ul>
<li>user_name</li>
<li>user_email</li>
</ul>
<figure class="highlight yml"><figcaption><span>.github/workflows/deploy.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">false</span> <span class="comment"># Checkout private submodules(themes or something else).</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;20&#x27;</span> <span class="comment"># Specify the Node.js version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $&#123;&#123; runner.os &#125;&#125;-node-</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@7b45fbba1ed6bde78f8ed2719ec9b7c0bd49e220</span>  <span class="comment">#v1.0.4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">user_name:</span> <span class="string">&quot;your name&quot;</span>  <span class="comment"># (or delete this input setting to use bot account)</span></span><br><span class="line">        <span class="attr">user_email:</span> <span class="string">&quot;github email&quot;</span>  <span class="comment"># (or delete this input setting to use bot account)</span></span><br><span class="line">        <span class="attr">commit_msg:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span>  <span class="comment"># (or delete this input setting to use hexo default settings)</span></span><br><span class="line">    <span class="comment"># Use the output from the `deploy` step(use for test action)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; steps.deploy.outputs.notify &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-部署"><a href="#3-3-部署" class="headerlink" title="3.3 部署"></a>3.3 部署</h2><p>其实已经部署完成了，每次push时，workflow都会自动运行，将博客部署到GitHub Pages上，只需要等待一会儿即可。但是因为我一直报错，各种奇怪的error，折腾了一下午还是决定放弃了，安慰自己方法1也很方便，就这样吧。</p>
<h1 id="4-插件-按需"><a href="#4-插件-按需" class="headerlink" title="4. 插件(按需)"></a>4. 插件(按需)</h1><h2 id="4-1-mermaid-思维导图"><a href="#4-1-mermaid-思维导图" class="headerlink" title="4.1 mermaid-思维导图"></a>4.1 mermaid-思维导图</h2><p><strong>版本说明</strong></p>
<ul>
<li>hexo: 7.1.1</li>
<li>hexo-cli: 4.3.1</li>
<li>NexT version 8.19.2<br>我使用的是Next 8.x.y版本, 网上有很多mermaid的配置教程, 但基本都基于8以下版本, 需要去修改footer.ejs文件, 但是在8.x.y版本中, 已经不需要修改footer.ejs文件了, 只需要安装插件即可.(ps: 如果盲目按照网上教程, 会发现没有.ejs文件, 在next8里只有njk文件, 此时如果强硬的修改njk, <code>hexo g</code>之后会发现铺天盖地的error了. 猜猜我为什么会知道)</li>
</ul>
<ol>
<li>安装插件<br><code>npm install hexo-filter-mermaid-diagrams</code></li>
<li>修改hexo的_config.yml<br>如果搜索不到mermaid, 则需要自行添加. 其中版本号不需要改, 似乎不是很重要<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure></li>
<li>修改themes/next的_config.yml<br>已经存在了, 只需要修改enable为true即可<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure></li>
<li>测试<br>写一个简单例子测试是否安装成功. 注意使用mermaid标签, 代码如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Christmas] --&gt;|Get money| B(Go shopping)</span><br><span class="line">    B --&gt; C&#123;Let me think&#125;</span><br><span class="line">    C --&gt;|One| D[Laptop]</span><br><span class="line">    C --&gt;|Two| E[iPhone]</span><br><span class="line">    C --&gt;|Three| F[fa:fa-car Car]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>执行以下命令，重新执行 Hexo 的编译构建操作，并启动 Hexo-Server 的预览服务，若 Mermaid 的绘图正常显示，则说明 Mermaid 成功被渲染。<br><code>hexo clean ; hexo generate ; hexo server</code></p>
<p><strong>效果图</strong></p>
<pre class="mermaid">graph LR
    A[Christmas] -->|Get money| B(Go shopping)
    B --> C{Let me think}
    C -->|One| D[Laptop]
    C -->|Two| E[iPhone]
    C -->|Three| F[fa:fa-car Car]</pre>

<p>啊….真的很丑陋….但是先这样吧, 暂且还没有找到网上说的css文件夹中的custom.styl文件, 以后再慢慢改吧</p>
<ol>
<li>语法<br><a href="https://soft.xiaoshujiang.com/docs/grammar/feature/mermaid/">mermaid语法</a></li>
</ol>
<h2 id="4-2-newpage后自动打开"><a href="#4-2-newpage后自动打开" class="headerlink" title="4.2 newpage后自动打开"></a>4.2 newpage后自动打开</h2><p>新建scripts文件夹，新建一个auto_open.js文件，内容如下<br>这里path/to/your/ide是你的编辑器的路径，例如”C:/Program Files/Notepad++/notepad++.exe”<br><figure class="highlight js"><figcaption><span>scripts/auto_open.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">exec</span>;</span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title function_">spawn</span>(<span class="string">&#x27;start  &quot;path/to/your/ide&quot; &#x27;</span> + data.<span class="property">path</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="4-3-图片上传"><a href="#4-3-图片上传" class="headerlink" title="4.3 图片上传"></a>4.3 图片上传</h2><p><strong>目标</strong><br>一般, 直接截图粘贴到md文件, 图片是存储在本地的(查看链接就可以看出来), 如果换了电脑, 或者换了文件夹, 图片就会丢失, 并且git.io上也是没法加载图的. 所以需要将图片上传到云端, 然后在md文件中插入图片的远端链接.</p>
<p>有下面两种方法</p>
<ol>
<li><p>安装hexo-asset-image插件<br>网上查的方法，但是对我没用…<br>安装插件hexo-asset-image:<br><code>npm install hexo-asset-image --save</code><br>在_config.yml中修改 post_asset_folder: true</p>
</li>
<li><p>图床<br>PicGO+SM.MS<br>想用github，但是上传失败，SM.MS免费又方便又快捷，强烈推荐，只要注册就有一个token，直接粘贴到PicGO中即可<br>具体使用方法：本地截图之后，复制到剪贴板，通过快捷键(一般是Alt+D)上传，上传成功后会自动复制图片链接，直接粘贴到markdown文件中即可，非常方便</p>
</li>
</ol>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>至此，hexo环境搭建，很折腾，但是终于拥有了人生第一个真正的（而且免费的）博客，还是很有成就感的。下一篇准备写一下hexo的基本语法。</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>latex语法</title>
    <url>/2024/03/26/latex%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="1-Latex语法"><a href="#1-Latex语法" class="headerlink" title="1. Latex语法"></a>1. Latex语法</h1><p>TODO: to fill …</p>
<h1 id="2-常用模板"><a href="#2-常用模板" class="headerlink" title="2. 常用模板"></a>2. 常用模板</h1><h2 id="2-1-简历模板"><a href="#2-1-简历模板" class="headerlink" title="2.1 简历模板"></a>2.1 简历模板</h2><p>网上大部分模板都是英文的, 用的compiler是Latex, 但是Latex对中文支持不是很好, XeLatex对中文支持较好, 但是模板不是很多. (可以尝试一下如果下载英文模板, 强行改成Xelatex, 填充中文内容, 大概率会报错…) 于是决定自己手搓一个. 把所有个人信息隐去后, 整理成了一个模板.</p>
<p>具体使用方法见github里的README.md, 里面有详细的使用方法和效果展示</p>
<p><a href="https://github.com/zhuyinna/latex_resume_template/tree/main">Github: 中文简历模板</a></p>
<h2 id="2-2-论文模板"><a href="#2-2-论文模板" class="headerlink" title="2.2 论文模板"></a>2.2 论文模板</h2><p>TODO: to fill …</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>Latex</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/03/24/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>二叉树是一种基础的数据结构. 本篇介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点. </p>
<pre class="mermaid">graph LR;
A("树") --- B("二叉树")
  B --- B1("完全二叉树") --- B11("满二叉树")
  B --- B2("平衡二叉树") 
    B2 --- B21("AVL树")
    B2 --- B22("红黑树")
    B2 --- B23("树堆Treap")
  B --- B3("二叉搜索树BST")
  B --- B4("线索二叉树")
A("树") --- C("堆")
  C --- C1("二叉堆")
    C1 --- C11("最大堆")
    C1 --- C12("最小堆")
  C --- C2("斐波那契堆")
  C --- C3("左偏树")
  C --- C4("二项堆")
A("树") --- D("B树")
  D --- D1("B+树")
  D --- D2("B*树")
A("树") --- E("字典树")</pre>

<h1 id="1-二叉树的种类"><a href="#1-二叉树的种类" class="headerlink" title="1. 二叉树的种类"></a>1. 二叉树的种类</h1><h2 id="1-1-满二叉树"><a href="#1-1-满二叉树" class="headerlink" title="1.1 满二叉树"></a>1.1 满二叉树</h2><ol>
<li><p>概念<br>满二叉树是一种特殊的二叉树，其中每个节点都有0个或2个子节点。满二叉树的特点是所有叶子节点都在同一层，且每个非叶子节点都有两个子节点。满二叉树的高度为log2(n+1)，其中n是节点数。</p>
<blockquote>
<p>即依次序排列从左到右，从上到下进行排列，每个节点都有两个子节点，直到最后一层的叶子节点。</p>
</blockquote>
</li>
<li><p>特点</p>
</li>
</ol>
<h2 id="1-2-完全二叉树"><a href="#1-2-完全二叉树" class="headerlink" title="1.2 完全二叉树"></a>1.2 完全二叉树</h2><ol>
<li><p>概念<br>没有满的满二叉树</p>
</li>
<li><p>存储<br>完全二叉树可以使用数组来存储，数组的下标从0开始，根节点的下标为0，左子节点的下标为2i+1，右子节点的下标为2i+2，父节点的下标为(i-1)/2。 平常使用完全二叉树的时候, 可以使用数组来存储, 便于索引且空间利用率最高.</p>
</li>
<li><p>特殊例子 - 堆</p>
</li>
</ol>
<h2 id="1-3-二叉搜索树"><a href="#1-3-二叉搜索树" class="headerlink" title="1.3 二叉搜索树"></a>1.3 二叉搜索树</h2><ol>
<li>概念<br>二叉搜索树是一个有序树, 任意节点的左子树的值都小于该节点的值, 任意节点的右子树的值都大于该节点的值.</li>
</ol>
<ol>
<li>题目<blockquote>
<ol>
<li>二叉搜索树中的搜索 - 给定一个二叉搜索树(Binary Search Tree)找到给定节点, 返回以该节点为根的子树. 如果节点不存在, 返回NULL.<div class="tabs" id="二叉搜索树中的搜索"><ul class="nav-tabs"><li class="tab active"><a href="#二叉搜索树中的搜索-1">迭代法</a></li><li class="tab"><a href="#二叉搜索树中的搜索-2">递归法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="二叉搜索树中的搜索-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="二叉搜索树中的搜索-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div></div>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="1-4-平衡二叉搜索树"><a href="#1-4-平衡二叉搜索树" class="headerlink" title="1.4 平衡二叉搜索树"></a>1.4 平衡二叉搜索树</h2><ol>
<li>概念<br>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li>
</ol>
<p><strong>2. C++中的容器</strong><br>「C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树」，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</p>
<h1 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2. 二叉树的遍历"></a>2. 二叉树的遍历</h1><h2 id="2-1-深度优先遍历"><a href="#2-1-深度优先遍历" class="headerlink" title="2.1 深度优先遍历"></a>2.1 深度优先遍历</h2><ol>
<li>前序遍历(递归法,迭代法)</li>
<li>中序遍历(递归法,迭代法)</li>
<li>后序遍历(递归法,迭代法)</li>
</ol>
<h2 id="2-2-广度优先遍历"><a href="#2-2-广度优先遍历" class="headerlink" title="2.2 广度优先遍历"></a>2.2 广度优先遍历</h2><ol>
<li>层序遍历(迭代法)</li>
</ol>
<h1 id="3-二叉树的定义"><a href="#3-二叉树的定义" class="headerlink" title="3. 二叉树的定义"></a>3. 二叉树的定义</h1><h2 id="3-1-链式存储"><a href="#3-1-链式存储" class="headerlink" title="3.1 链式存储"></a>3.1 链式存储</h2><div class="tabs" id="二叉树链式存储代码实现"><ul class="nav-tabs"><li class="tab active"><a href="#二叉树链式存储代码实现-1">cpp</a></li><li class="tab"><a href="#二叉树链式存储代码实现-2">python</a></li></ul><div class="tab-content"><div class="tab-pane active" id="二叉树链式存储代码实现-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="二叉树链式存储代码实现-2"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div></div>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划理论基础</title>
    <url>/2024/03/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>动态规划（Dynamic Programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法通常用于求解最优化问题。</p>
<h1 id="1-动规五部曲"><a href="#1-动规五部曲" class="headerlink" title="1. 动规五部曲"></a>1. 动规五部曲</h1><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><h2 id="2-1-509-斐波那契数"><a href="#2-1-509-斐波那契数" class="headerlink" title="2.1 509-斐波那契数"></a>2.1 509-斐波那契数</h2><p>leetcode题目链接 - <a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></p>
<ol>
<li>dp数组以及下标的含义<br>dp[i]的定义为：第i个斐波那契数的值为dp[i]</li>
<li>递推公式<br>dp[i] = dp[i-1] + dp[i-2]</li>
<li>dp数组初始化<br>dp[0] = 0, dp[1] = 1</li>
<li>遍历顺序<br>从前往后遍历</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="2-2-70-爬楼梯"><a href="#2-2-70-爬楼梯" class="headerlink" title="2.2 70-爬楼梯"></a>2.2 70-爬楼梯</h2><p>leetcode题目链接 - <a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></p>
<ol>
<li>dp数组以及下标的含义<br>dp[i]的定义为：爬到第i阶楼梯的方法数为dp[i]</li>
<li>递推公式<br>从i-1到达i + 从i-2到达i,<br>dp[i] = dp[i-1] + dp[i-2]</li>
<li>dp数组初始化<br>注意题目中强调n为正整数,所以不用考虑0<br>dp[1] = 1, dp[2] = 2</li>
<li>遍历顺序<br>从前往后遍历</li>
<li>举例推导dp数组<br>1, 1, 2, 3…</li>
</ol>
<h2 id="2-3-746-使用最小花费爬楼梯"><a href="#2-3-746-使用最小花费爬楼梯" class="headerlink" title="2.3 746-使用最小花费爬楼梯"></a>2.3 746-使用最小花费爬楼梯</h2><p>leetcode题目链接 - <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></p>
<ol>
<li>dp数组以及下标的含义<br>dp[i]定义为到达i台阶最小花费</li>
<li>递推公式<br>假设一踩到台阶,就会耗费体力. 这里cost[i-1]原因是: dp数组从1开始, cost数组从0开始<br>dp[i] = min(dp[i-1], dp[i-2]) + cost[i-1]<br>return值:注意这里<code>return min(dp[n],dp[n-1])</code></li>
<li>dp数组初始化<br>dp[0] = 0, dp[1] = cost[0]</li>
<li>遍历顺序<br>从前往后遍历</li>
</ol>
<h2 id="2-4-62-不同路径"><a href="#2-4-62-不同路径" class="headerlink" title="2.4 62-不同路径"></a>2.4 62-不同路径</h2><p>leetcode题目链接 - <a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></p>
<ol>
<li>dp数组以及下标的含义<br>dp[i][j]的定义为：到达坐标(i,j)的路径数为dp[i][j]</li>
<li>递推公式<br><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></li>
<li>dp数组初始化<br><code>dp[0][j] = 1, dp[i][0] = 1</code></li>
<li>遍历顺序<br>i:1-&gt;m, j:1-&gt;n</li>
</ol>
<h2 id="2-5-63-不同路径II"><a href="#2-5-63-不同路径II" class="headerlink" title="2.5 63-不同路径II"></a>2.5 63-不同路径II</h2><p>leetcode题目链接 - <a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a><br>和62题类似,只是加了障碍物,不同点:</p>
<ol>
<li>初始化<br>dp[0][j] = 1, dp[i][0] = 1, 如果遇到障碍物,则后面的都是0</li>
<li>递推公式<br>和62题一样,只是加了障碍物判断: 如果是障碍物,则dp[i][j] = 0</li>
</ol>
<h2 id="2-6-343-整数拆分"><a href="#2-6-343-整数拆分" class="headerlink" title="2.6 343-整数拆分"></a>2.6 343-整数拆分</h2><p>leetcode题目链接 - <a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a></p>
<ol>
<li>dp数组以及下标的含义<br>dp[i]的定义为：整数i拆分后的最大乘积为dp[i]</li>
<li>递推公式<br>不拆分dp[i]/拆分成两部分j和i-j,其中i-j可以继续拆分或者不拆分<br>dp[i] = max(dp[i], max(j<em>dp[i-j],j</em>(i-j)))</li>
<li>dp数组初始化<br>dp[2] = 1</li>
<li>遍历顺序<br>i:[2,n], j:[1,i-1]</li>
</ol>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96-不同的二叉搜索树"></a>96-不同的二叉搜索树</h2><p>leetcode题目链接 - <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p>
<ol>
<li>dp数组以及下标的含义<br>i为根节点,dp[i]为以i为根节点的二叉搜索树的个数</li>
<li>递推公式<br>dp[i]表示总共有i个节点,有几个树. 其中j作为根节点时,左子树有j-1个节点,右子树有i-j个节点, j需要从1到i遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">        dp[i] += dp[j-<span class="number">1</span>]*dp[i-j]</span><br></pre></td></tr></table></figure></li>
<li>dp数组初始化<br>注意这里虽然n不会是0,但是考虑到后面是左右子树如果一颗空树的时候,不能乘以0,所以必须改成1<br>dp[0]=1, dp[1]=1, dp[2]=2</li>
<li>遍历顺序<br>i:[1,n]</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法合集</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习CV算法八股文</title>
    <url>/2024/03/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0CV%E7%AE%97%E6%B3%95%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<p>过/欠拟合 &amp; 梯度消失/爆炸 &amp; 权重初始化 &amp; 梯度下降法 &amp;学习率 &amp; 正则化 &amp; Batch Normalization…<br><span id="more"></span></p>
<h1 id="1-过拟合"><a href="#1-过拟合" class="headerlink" title="1. 过拟合"></a>1. 过拟合</h1><p>可能原因</p>
<ul>
<li>训练数据大小过小，并且未包含足够的数据样本，无法准确代表所有可能的输入数据值。</li>
<li>训练数据包含大量不相关的信息，称为噪声数据。</li>
<li>模型在单个数据样本集上训练的时间过长。</li>
<li>模型复杂程度较高，因此其可以学习训练数据中的噪声。</li>
</ul>
<p>本质原因<br>神经网络就是一个函数，对其进行傅里叶变换求得频谱，频谱中低频分量就是变化平滑的部分，高频分量就是变化敏感的部分。模型对于微小扰动的反馈差异大实际就是一个过拟合的表现，也就是高频分量不能多</p>
<p>解决方法</p>
<ul>
<li>数据增强</li>
<li>L1/L2正则化</li>
<li>Dropout正则化</li>
<li>Early stopping</li>
<li>Batch normalization</li>
</ul>
<h2 id="1-1-L1-L2正则化"><a href="#1-1-L1-L2正则化" class="headerlink" title="1.1 L1/L2正则化"></a>1.1 L1/L2正则化</h2><p>L1正则化直接在损失函数上加上权重的绝对值,会使权重稀疏</p>
<script type="math/tex; mode=display">\begin{aligned}\mathrm{loss}&=\mathrm{J}\left(\mathrm{w},\mathrm{b}\right)+\frac\lambda{2\mathrm{m}}\sum|\mathrm{w}|\end{aligned}</script><p>L2正则化在损失函数上加上权重的平方和,会使权重更加平滑</p>
<script type="math/tex; mode=display">\mathrm{loss}=\mathrm{J}\left(\mathrm{w},\mathrm{b}\right)+\frac{\lambda}{2\mathrm{m}}\sum\lVert\mathrm{w}\rVert_{\mathrm{F}}^2</script><h2 id="1-2-Dropout"><a href="#1-2-Dropout" class="headerlink" title="1.2 Dropout"></a>1.2 Dropout</h2><h3 id="1-2-1-Dropout正则化"><a href="#1-2-1-Dropout正则化" class="headerlink" title="1.2.1 Dropout正则化"></a>1.2.1 Dropout正则化</h3><p>Dropout正则化是指在训练过程中，随机将神经网络中的一部分神经元的输出设置为0，从而减少神经元之间的依赖关系，防止过拟合。</p>
<p>训练</p>
<ul>
<li>训练时，每个神经元都有概率1-p被保留，概率p被丢弃. 参数多的层，p可以设置小一点，参数少的层，p可以设置大一点</li>
<li>删除神经网络节点和从该节点进出的连线</li>
</ul>
<p>推理</p>
<ul>
<li>推理时，所有神经元都保留，但是输出值乘以1-p(rescale)</li>
</ul>
<p>原因<br>dropout带有随机性, 如果infer也使用, 会导致每次推理结果不一致, 所以在推理时, 保留所有神经元, 但是为了保持期望值不变,保证训练和推理的分布一致, 进行rescale</p>
<p>本质<br>Dropout最终产⽣收缩权重的平方范数的效果，压缩权重效果类似L2正则化</p>
<h3 id="1-2-2-Vanilla-Dropout"><a href="#1-2-2-Vanilla-Dropout" class="headerlink" title="1.2.2 Vanilla Dropout"></a>1.2.2 Vanilla Dropout</h3><p>forward时候进行mask, backward时梯度和输入保持一致(也要mask), infer时进行1-p的rescale. (如1.2.1所述, 训练时候因为随机扔掉了一些节点，总期望变小，那么预测时候就全体缩小一点来保持一致)</p>
<p><strong>问题</strong>: 训练时候因为随机扔掉了一些节点，总期望变小，那么预测时候就全体缩小一点来保持一致。</p>
<h3 id="1-2-3-Inverted-Dropout（反向随机失活）"><a href="#1-2-3-Inverted-Dropout（反向随机失活）" class="headerlink" title="1.2.3 Inverted Dropout（反向随机失活）"></a>1.2.3 Inverted Dropout（反向随机失活）</h3><p>和Vanilla Dropout区别: 训练, 梯度, 预测</p>
<ul>
<li>产生⼀个[0,1)的随机矩阵，维度与权重矩阵相同</li>
<li>设置节点保留概率keep_prob 并与随机矩阵比较，小于为1，大于为0</li>
<li>将权重矩阵与0-1矩阵对应相乘得到新权重矩阵</li>
<li>对新权重矩阵除于keep_prob（保证输⼊均值和输出均值一致），保证权重矩阵均值不变，层输出不变</li>
</ul>
<p><strong>改进</strong>: 把所有修改放在训练阶段,保持预测阶段不变。 保持预测阶段不变。</p>
<h3 id="1-3-Early-Stopping"><a href="#1-3-Early-Stopping" class="headerlink" title="1.3 Early Stopping"></a>1.3 Early Stopping</h3><p>在训练中计算模型在验证集上的表现，当模型在验证集上的误差开始增大时，停止训练。这样就可以避免继续训练导致的过拟合问题. 训练时间和泛化误差的权衡。提早停⽌训练神经网络得到⼀个中等大小的W的F范数，与L2正则化类似<br><img src="https://s2.loli.net/2024/03/25/pjtE47vfsadSxkH.png" alt=""></p>
<h1 id="2-欠拟合"><a href="#2-欠拟合" class="headerlink" title="2. 欠拟合"></a>2. 欠拟合</h1><p>增加模型复杂度，增加训练数据量，减少正则化参数，减少dropout参数</p>
<h1 id="3-梯度消失和梯度爆炸"><a href="#3-梯度消失和梯度爆炸" class="headerlink" title="3. 梯度消失和梯度爆炸"></a>3. 梯度消失和梯度爆炸</h1><h2 id="3-1-原因"><a href="#3-1-原因" class="headerlink" title="3.1 原因"></a>3.1 原因</h2><p>深层网络, 或者不合适的loss函数</p>
<script type="math/tex; mode=display">\Delta w_1=\frac{\partial Loss}{\partial w_2}=\frac{\partial Loss}{\partial f_4}\frac{\partial f_4}{\partial f_3}\frac{\partial f_3}{\partial f_2}\frac{\partial f_2}{\partial w_2},</script><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.11ex;" xmlns="http://www.w3.org/2000/svg" width="3.383ex" height="3.351ex" role="img" focusable="false" viewBox="0 -990.5 1495.4 1481.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,485) scale(0.707)"><g data-mml-node="mi"><path data-c="1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path></g><g data-mml-node="msub" transform="translate(566,0)"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g><g data-mml-node="mrow" transform="translate(220,-345.6) scale(0.707)"><g data-mml-node="mi"><path data-c="1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path></g><g data-mml-node="msub" transform="translate(566,0)"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g><rect width="1255.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>是对激活函数求导<br>大于1: 随着层数增加,梯度爆炸<br>小于1: 随着层数增加, 梯度消失</p>
<blockquote>
<p>从深层网络角度来讲，不同的层学习的速度差异很大，表现为网络中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前几层的权值和刚开始随机初始化的值差不多</p>
<p>TODO: 查阅Hinton提出的capsule, 抛弃反向传播</p>
</blockquote>
<h2 id="3-2-激活函数"><a href="#3-2-激活函数" class="headerlink" title="3.2 激活函数"></a>3.2 激活函数</h2><ol>
<li><p>sigmoid函数</p>
<script type="math/tex; mode=display">sigmoid(x)=\frac1{1+e^{-x}}</script><p>其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失<br><img src="https://s2.loli.net/2024/03/25/Aqjaysel3nFItM2.png" width="50%"><img src="https://s2.loli.net/2024/03/25/GnCu5OblpEU1tie.png" width="50%"></p>
</li>
<li><p>tanh</p>
<script type="math/tex; mode=display">tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}</script><p>好一些, 但是倒数仍然小于1<br><img src="https://s2.loli.net/2024/03/25/deKWv5f8Rs2TSAZ.png" width="100%"></p>
</li>
</ol>
<h2 id="3-3-解决方案"><a href="#3-3-解决方案" class="headerlink" title="3.3 解决方案"></a>3.3 解决方案</h2><div class="note info"><p><strong>解决梯度消失的方法</strong></p>
<ul>
<li>Relu及其变体</li>
<li>LSTM/GRU</li>
<li>残差结构</li>
<li>BatchNorm</li>
<li>Xavier初始化(修正w的方差，避免w过小)<br><strong>解决梯度爆炸的方法</strong></li>
<li>梯度裁剪</li>
<li>正则化(将w加入Loss里，如果Loss小则w也要小，而梯度爆炸是w过大[绝对值]造成的)</li>
<li>Xavier初始化(修正w的方差，避免w过大)</li>
<li>BatchNorm</li>
</ul>
</div>
<h3 id="3-3-1-预训练-微调"><a href="#3-3-1-预训练-微调" class="headerlink" title="3.3.1 预训练+微调"></a>3.3.1 预训练+微调</h3><p>逐层预训练,再对整个网络微调. 核心思想:先寻找局部最优, 整合后寻找全局最优</p>
<h3 id="3-3-2-梯度剪切-正则"><a href="#3-3-2-梯度剪切-正则" class="headerlink" title="3.3.2 梯度剪切+正则"></a>3.3.2 梯度剪切+正则</h3><p>剪切: 设置梯度阈值, 如果超出则强制限制, 防止梯度爆炸.<br>权重正则化: L1正则, L2正则 </p>
<script type="math/tex; mode=display">Loss=(y-W^Tx)^2+\alpha||W||^2</script><h3 id="3-3-3-relu-leakrelu-elu激活函数"><a href="#3-3-3-relu-leakrelu-elu激活函数" class="headerlink" title="3.3.3 relu/leakrelu/elu激活函数"></a>3.3.3 relu/leakrelu/elu激活函数</h3><ol>
<li>Relu</li>
</ol>
<ul>
<li>解决梯度消失/爆炸; 计算方便速度快; 加速训练</li>
<li>由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）; 输出不是以0为中心的</li>
</ul>
<script type="math/tex; mode=display">\left.\text{Relu(x)=}\max(x,0)=\left\lbrace\begin{aligned}0,x<0\\\\x,x>0\end{aligned}\right.\right\rbrace</script><p><img src="https://s2.loli.net/2024/03/25/fUAJZiF3LvCEtHu.png" width="100%"></p>
<ol>
<li>Leakrelu</li>
</ol>
<ul>
<li>改进relu的0区间问题</li>
</ul>
<script type="math/tex; mode=display">\left.leakrelu=f(x)=\left\{\begin{array}{ll}x,&x>0\\\\x*k,&x\leq0\end{array}\right.\right.</script><p><img src="https://s2.loli.net/2024/03/25/OuhysixpFcNDdY8.png" width="100%"></p>
<h3 id="3-3-4-Batchnorm"><a href="#3-3-4-Batchnorm" class="headerlink" title="3.3.4 Batchnorm"></a>3.3.4 Batchnorm</h3><p>反向传播式子中有w的存在，所以w的大小影响了梯度的消失和爆炸，batchnorm就是通过对每一层的输出做scale和shift的方法，通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到接近均值为0方差为1的标准正太分布，即严重偏离的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，使得让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。</p>
<h2 id="3-5-残差结构"><a href="#3-5-残差结构" class="headerlink" title="3.5 残差结构"></a>3.5 残差结构</h2><p>式子的第一个因子<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.022ex;" xmlns="http://www.w3.org/2000/svg" width="4.654ex" height="3.057ex" role="img" focusable="false" viewBox="0 -899.6 2057.2 1351.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path></g><g data-mml-node="mi" transform="translate(566,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(864,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1349,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1818,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g><g data-mml-node="mrow" transform="translate(426.6,-345.6) scale(0.707)"><g data-mml-node="mi"><path data-c="1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path></g><g data-mml-node="msub" transform="translate(566,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="TeXAtom" transform="translate(605,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></g><rect width="1817.2" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>表示的损失函数到达 L 的梯度，小括号中的1表明短路机制可以无损地传播梯度，而另外一项残差梯度则需要经过带有weights的层，梯度不是直接传递过来的。残差梯度不会那么巧全为-1，而且就算其比较小，有1的存在也不会导致梯度消失。所以残差学习会更容易。</p>
<script type="math/tex; mode=display">\frac{\partial loss}{\partial x_{l}}=\frac{\partial loss}{\partial x_{L}}\cdot\frac{\partial x_{L}}{\partial x_{l}}=\frac{\partial loss}{\partial x_{L}}\cdot\left(1+\frac{\partial}{\partial x_{L}}\sum_{i=l}^{L-1}F(x_{i},W_{i})\right)</script><blockquote>
<p>上述推导不严格, 只是助于理解</p>
</blockquote>
<h2 id="3-6-LSTM"><a href="#3-6-LSTM" class="headerlink" title="3.6 LSTM"></a>3.6 LSTM</h2><p>TODO: 待补充<br><img src="https://s2.loli.net/2024/03/25/ypv2Nz8hk1KBEXe.png" width="100%"></p>
<h1 id="4-神经网络权重初始化"><a href="#4-神经网络权重初始化" class="headerlink" title="4. 神经网络权重初始化"></a>4. 神经网络权重初始化</h1><ul>
<li>初始化为0</li>
<li>随机初始化</li>
<li>Xavier initialization</li>
<li>He initialization<br>其中初始化为0不可取, 那么每一层的神经元学到的东西都是一样的（输出是一样的），而且在bp的时候，每一层内的神经元也是相同的，因为他们的gradient相同。 随机初始化时, 需要乘一个值(eg.0.01)是因为要把W随机初始化到一个相对较小的值, 防止遇到如sigmoid函数会导致costfunction里的log是0. 缺点是: np.random.randn()其实是一个均值为0，方差为1的高斯分布中采样。当神经网络的层数增多时，会发现越往后面的层的激活函数（使用tanH）的输出值几乎都接近于0</li>
</ul>
<h2 id="4-1-Xavier"><a href="#4-1-Xavier" class="headerlink" title="4.1 Xavier"></a>4.1 Xavier</h2><p>思想: 尽可能的让输入和输出服从相同的分布，这样就能够避免后面层的激活函数的输出值趋向于0<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">3</span>)</span><br><span class="line">parameters = {}</span><br><span class="line">L = <span class="built_in">len</span>(layers_dims)  <span class="comment"># integer representing the number of layers</span></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">    parameters[<span class="string">'W'</span> + <span class="built_in">str</span>(l)] = np.random.randn(layers_dims[l], layers_dims[l - <span class="number">1</span>]) * np.sqrt(<span class="number">1</span> / layers_dims[l - <span class="number">1</span>])</span><br><span class="line">    parameters[<span class="string">'b'</span> + <span class="built_in">str</span>(l)] = np.zeros((layers_dims[l], <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><br>虽然Xavier initialization能够很好的 tanH 激活函数，但是对于目前神经网络中最常用的ReLU激活函数, 还是会趋向于0</p>
<h2 id="4-2-He-initialization"><a href="#4-2-He-initialization" class="headerlink" title="4.2 He initialization"></a>4.2 He initialization</h2><p>一种针对ReLU的初始化方法<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">3</span>)</span><br><span class="line">parameters = {}</span><br><span class="line">L = <span class="built_in">len</span>(layers_dims)  <span class="comment"># integer representing the number of layers</span></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">    parameters[<span class="string">'W'</span> + <span class="built_in">str</span>(l)] = np.random.randn(layers_dims[l], layers_dims[l - <span class="number">1</span>]) * np.sqrt(<span class="number">2</span> / layers_dims[l - <span class="number">1</span>])</span><br><span class="line">    parameters[<span class="string">'b'</span> + <span class="built_in">str</span>(l)] = np.zeros((layers_dims[l], <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure></p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>参考文献<br><a href="https://blog.csdn.net/u012328159/article/details/80025785">深度学习中神经网络的几种权重初始化方法_神经网络权重初始化方法-CSDN博客</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>CV算法</category>
      </categories>
  </entry>
  <entry>
    <title>批处理文件编写</title>
    <url>/2024/03/24/%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>批处理文件(.bat, batch file)是一种文本文件，其中包含一系列命令，这些命令通常是操作系统命令。批处理文件通常用于执行重复的任务，例如安装软件，配置系统设置等。批处理文件通常使用扩展名.bat或.cmd。在Windows系统中，批处理文件可以通过双击文件或在命令提示符下运行来执行。</p>
<h1 id="1-批处理文件编写教程"><a href="#1-批处理文件编写教程" class="headerlink" title="1 批处理文件编写教程"></a>1 批处理文件编写教程</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>批处理文件(.bat, batch file)是一种文本文件，其中包含一系列命令，这些命令通常是操作系统命令。批处理文件通常用于执行重复的任务，例如安装软件，配置系统设置等。批处理文件通常使用扩展名.bat或.cmd。在Windows系统中，批处理文件可以通过双击文件或在命令提示符下运行来执行。</p>
<h2 id="1-2-创建"><a href="#1-2-创建" class="headerlink" title="1.2 创建"></a>1.2 创建</h2><p>在win系统中，可以使用记事本创建批处理文件，然后将其保存为.bat或.cmd文件。快捷键设置：右键-&gt;快捷方式-&gt;快捷键，设置快捷键，以便在需要时快速运行。</p>
<blockquote>
<p>注意：如果.bat文件中包含中文字符，在保存时需要选择ANSI编码，否则可能会出现乱码。</p>
</blockquote>
<h2 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h2><p>TODO: to fill …</p>
<h1 id="2-常用用例"><a href="#2-常用用例" class="headerlink" title="2 常用用例"></a>2 常用用例</h1><h2 id="2-1-win系统"><a href="#2-1-win系统" class="headerlink" title="2.1 win系统"></a>2.1 win系统</h2><ol>
<li>系统操作<br>关机：<code>shutdown -s -t 0</code><br>重启：<code>shutdown -r -t 0</code><br>注销：<code>shutdown -l</code></li>
</ol>
<blockquote>
<p>参数说明：-t 0表示立即执行，-t 60表示60秒后执行</p>
</blockquote>
<ol>
<li>用vscode打开指定目录<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="comment">REM start your program, if the path has space</span></span><br><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;C:\<span class="built_in">Path</span>\To\Your\Microsoft VS Code\Code.exe&quot; &quot;D:\<span class="built_in">Path</span>\To\Your\Blog&quot;</span><br><span class="line"><span class="comment">REM exit this cmd</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
        <category>Bat脚本</category>
      </categories>
      <tags>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2024/03/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p><em>Not completed …</em></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法合集</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
</search>
